<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Unified Game Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/acorn/8.11.3/acorn.min.js"></script>
    <style>
        :root {
            --bg: #111;
            --panel: #1a1a1a;
            --border: #333;
            --accent: #0066cc;
            --error: #cc3300;
            --text: #eee;
            --code: #aaddff;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Consolas', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Layout */
        #header {
            background: #222;
            padding: 0 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 2px;
        }

        .tab-btn {
            background: #333;
            border: none;
            color: #888;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 5px;
            border-radius: 5px 5px 0 0;
            transition: 0.2s;
        }

        .tab-btn.active {
            background: #444;
            color: #fff;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            flex: 1;
            height: calc(100vh - 40px);
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        /* UI Components */
        .pane-sidebar {
            width: 450px;
            background: var(--panel);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            padding: 10px;
            overflow-y: auto;
        }

        .pane-preview {
            flex: 1;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        textarea {
            background: #111;
            color: #0f0;
            border: 1px solid var(--border);
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            resize: none;
            line-height: 1.4;
            tab-size: 4;
            outline: none;
        }

        .code-editor {
            background: #0d1117;
            color: #e6edf3;
            border: 1px solid #30363d;
            flex: 1;
            min-height: 200px;
            white-space: pre;
            overflow-x: auto;
            font-size: 12px;
        }

        .code-editor:focus {
            border-color: var(--accent);
        }

        .code-editor.error {
            border-color: var(--error);
            background: #1a0505;
        }

        h3 {
            margin: 15px 0 5px;
            font-size: 14px;
            color: #aaa;
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
        }

        select,
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px;
            cursor: pointer;
            font-family: inherit;
        }

        button.primary {
            background: var(--accent);
            border-color: #0088ff;
        }

        .row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .flex-1 {
            flex: 1;
        }

        .status-msg {
            font-size: 11px;
            margin-top: 5px;
            min-height: 1.4em;
        }

        .status-ok {
            color: #0f0;
        }

        .status-err {
            color: #f55;
        }

        .tip {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <div id="header">
        <button class="tab-btn active" data-target="editor">1. Terrain Editor</button>
        <button class="tab-btn" data-target="gallery">2. Noise Lab</button>
        <button class="tab-btn" data-target="bullet-sim">3. Bullet Sim</button>
        <button class="tab-btn" data-target="enemy-sim">4. Enemy Sim</button>
    </div>

    <!-- TAB 1: Terrain Editor -->
    <div id="editor" class="tab-content active">
        <div class="pane-sidebar">
            <h3>Terrain Presets (Global Library)</h3>
            <div class="row">
                <select id="terrain-preset" class="flex-1"></select>
                <button class="primary" id="btn-apply-terrain">Apply</button>
            </div>
            <textarea id="input-terrain" spellcheck="false" class="flex-1"></textarea>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-terrain" width="600" height="800"></canvas>
        </div>
    </div>

    <!-- TAB 2: Noise Lab -->
    <div id="gallery" class="tab-content">
        <div class="pane-sidebar">
            <h3>Algorithm Selection (Global Library)</h3>
            <div class="row">
                <select id="select-algo" class="flex-1"></select>
            </div>

            <h3>Parameters</h3>
            <textarea id="input-noise" spellcheck="false" style="height:80px; min-height:80px; color:#8f8;"></textarea>

            <h3>Source Code (Live AST Parsing)</h3>
            <textarea id="code-editor" class="code-editor" spellcheck="false"></textarea>

            <div id="compile-status" class="status-msg status-ok">Ready.</div>
            <button class="primary" id="btn-apply-noise" style="width:100%; margin-top:5px; height: 40px;">
                AST CHECK & COMPILE
            </button>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-noise" width="600" height="600"></canvas>
        </div>
    </div>

    <!-- TAB 3: Bullet Simulator -->
    <div id="bullet-sim" class="tab-content">
        <div class="pane-sidebar">
            <h3>Player Config</h3>
            <textarea id="input-player-config" spellcheck="false" style="height:100px; color:#8f8;">{
    "speed": 4,
    "fireRate": 5,
    "color": "#0ff"
}</textarea>

            <h3>Bullet Selection (Global Library)</h3>
            <div class="row">
                <select id="select-bullet" class="flex-1"></select>
                <button class="primary" id="btn-load-bullet">Load</button>
            </div>

            <h3>Bullet Config (Spawn Script)</h3>
            <textarea id="input-bullet-config" class="code-editor" spellcheck="false" style="height:120px;">
            // Spiral Pattern
            const count = 5;
            for(let i=0; i<count; i++) {
                ctx.spawn({
                    speed: 4,
                    angle: (t * 5) + (i * (360/count)),
                    color: '#ff0'
                });
            }</textarea>

            <h3>Bullet Behavior (Trajectory Script)</h3>
            <textarea id="input-bullet-behavior" class="code-editor" spellcheck="false"
                style="height:100px;"></textarea>

            <div id="bullet-compile-status" class="status-msg status-ok">Ready.</div>
            <div id="bullet-debug" class="status-msg" style="color:#aaa;">Debug: Waiting...</div>
            <button class="primary" id="btn-apply-bullet">Apply Config</button>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-bullet" width="600" height="600"></canvas>
        </div>
    </div>

    <!-- TAB 4: Enemy Simulator -->
    <div id="enemy-sim" class="tab-content">
        <div class="pane-sidebar">
            <h3>Enemy Selection (Global Library)</h3>
            <div class="row">
                <select id="select-enemy" class="flex-1"></select>
                <button class="primary" id="btn-load-enemy">Load</button>
            </div>

            <h3>Enemy Config</h3>
            <textarea id="input-enemy-config" spellcheck="false" style="height:100px; color:#8f8;"></textarea>

            <h3>AI Logic (AST Parsed)</h3>
            <textarea id="input-enemy-ai" class="code-editor" spellcheck="false"></textarea>

            <div id="enemy-compile-status" class="status-msg status-ok">Ready.</div>
            <button class="primary" id="btn-apply-enemy">AST CHECK & COMPILE</button>
            <button id="btn-reset-enemy" style="margin-top:5px;">Reset Enemy</button>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-enemy" width="600" height="600"></canvas>
        </div>
    </div>

    <!-- LOAD UNIFIED DATA -->
    <script src="../utils.js"></script>
    <script src="../data/core.js"></script>
    <script src="../data/library/noise.js"></script>
    <script src="../data/library/terrains.js"></script>
    <script src="../data/library/enemies.js"></script>
    <script src="../data/library/bullets.js"></script>
    <script src="../data/library/bosses.js"></script>
    <script src="../data/library/scripts.js"></script>

    <script>
        /**
         * ============================================================================
         * MODULE 0: AST PARSER HELPER
         * ============================================================================
         */
        class CodeParser {
            static extractBody(fnString) {
                if (!window.acorn) return this.fallbackExtract(fnString);
                try {
                    let codeToParse = fnString.trim();
                    if (!codeToParse.startsWith('function') && !codeToParse.startsWith('(')) {
                        codeToParse = 'function ' + codeToParse;
                    }
                    const ast = acorn.parse(codeToParse, { ecmaVersion: 2020 });
                    let bodyNode = null;
                    const walk = (node) => {
                        if (bodyNode) return;
                        if (node.type === 'BlockStatement') { bodyNode = node; return; }
                        for (const key in node) {
                            if (node[key] && typeof node[key] === 'object') {
                                if (Array.isArray(node[key])) node[key].forEach(walk);
                                else walk(node[key]);
                            }
                        }
                    };
                    walk(ast);
                    if (bodyNode) return codeToParse.substring(bodyNode.start + 1, bodyNode.end - 1).trim();
                } catch (e) { console.warn("AST Fallback"); }
                return this.fallbackExtract(fnString);
            }
            static validate(bodyCode, args) {
                if (!window.acorn) return { valid: true };
                const wrapped = `function check(${args}) { ${bodyCode} }`;
                try {
                    acorn.parse(wrapped, { ecmaVersion: 2020 });
                    return { valid: true };
                } catch (e) {
                    return { valid: false, message: e.message, pos: Math.max(0, e.pos - (16 + args.length)) };
                }
            }
            static fallbackExtract(str) {
                const s = str.indexOf('{'), e = str.lastIndexOf('}');
                return (s === -1 || e === -1) ? str : str.substring(s + 1, e).trim();
            }
        }

        /**
         * ============================================================================
         * MODULE 1: NOISE GENERATOR (Uses GameData.Library.Noise)
         * ============================================================================
         */
        class NoiseGenerator {
            constructor() {
                // Wrapper to access GameData.Library.Noise
            }
            get(name) {
                return GameData.Library.Noise[name] || GameData.Library.Noise.value;
            }
            getSourceBody(name) {
                const fn = GameData.Library.Noise[name];
                if (!fn) return "// No source available";
                return CodeParser.extractBody(fn.toString());
            }
            replace(name, bodyStr) {
                const check = CodeParser.validate(bodyStr, 'x, y, t, M, N');
                if (!check.valid) throw new Error(`Syntax Error at char ${check.pos}: ${check.message}`);
                const fn = new Function('x', 'y', 't', 'M', 'N', bodyStr);
                // Update Global Library
                GameData.registerNoise(name, fn);
                return true;
            }
        }

        /**
         * ============================================================================
         * MODULE 2: TERRAIN SYSTEM (Uses GameData.Library.Terrains)
         * ============================================================================
         */
        class TerrainSystem {
            constructor(noiseGen) { this.noise = noiseGen; }
            evaluate(x, y, width, config) {
                if (config.Walls) {
                    let limitL = 0, limitR = width;
                    for (const w of config.Walls) {
                        const val = Math.sin(y * w.freq) * w.amp + w.offset;
                        if (w.side === 'left') limitL = Math.max(limitL, val);
                        if (w.side === 'right') limitR = Math.min(limitR, width - val);
                    }
                    if (config.Walls.find(w => w.side === 'left') && x < limitL) return { type: 'wall', color: config.Walls.find(w => w.side === 'left').color };
                    if (config.Walls.find(w => w.side === 'right') && x > limitR) return { type: 'wall', color: config.Walls.find(w => w.side === 'right').color };
                }
                if (config.Ground) {
                    const g = config.Ground;
                    const fn = this.noise.get(g.type);
                    const n = fn(x * g.scale, y * g.scale);
                    if (n > g.threshold) return { type: 'ground', color: g.color };
                }
                if (config.Background) {
                    const b = config.Background;
                    const fn = this.noise.get(b.type);
                    const n = fn(x * b.scale, y * b.scale);
                    if (n > b.threshold) return { type: 'bg', color: b.color };
                }
                return { type: 'none', color: null };
            }
        }

        class Visualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }
            drawTerrain(sys, config, scrollY) {
                this.ctx.fillStyle = config.clearColor || '#000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                const DOT = 4;
                const rows = Math.ceil(this.height / DOT), cols = Math.ceil(this.width / DOT);
                for (let r = 0; r < rows; r++) {
                    const y = r * DOT;
                    const worldY = y - scrollY;
                    for (let c = 0; c < cols; c++) {
                        const x = c * DOT;
                        const res = sys.evaluate(x, worldY, this.width, config);
                        if (res.type !== 'none') {
                            this.ctx.fillStyle = res.color;
                            this.ctx.fillRect(x, y, DOT, DOT);
                        }
                    }
                }
            }
            drawNoise(gen, algo, params, time) {
                const idata = this.ctx.createImageData(this.width, this.height);
                const data = idata.data;
                const fn = gen.get(algo);
                const scale = params.scale || 8;
                // Pass GameData.NoiseMath as context
                const M = Math;
                const N = GameData.NoiseMath;

                for (let py = 0; py < this.height; py++) {
                    for (let px = 0; px < this.width; px++) {
                        const x = px / (this.width / scale);
                        const y = py / (this.height / scale);
                        let val = fn(x, y + time, M, N);
                        val = Math.max(0, Math.min(1, val));
                        const c = Math.floor(val * 255);
                        const idx = (px + py * this.width) * 4;
                        if (params.colorize) {
                            data[idx] = c; data[idx + 1] = 255 - c; data[idx + 2] = c / 2; data[idx + 3] = 255;
                        } else {
                            data[idx] = c; data[idx + 1] = c; data[idx + 2] = c; data[idx + 3] = 255;
                        }
                    }
                }
                this.ctx.putImageData(idata, 0, 0);
            }
        }

        /**
         * ============================================================================
         * MODULE 3: BULLET SIMULATOR
         * ============================================================================
         */
        const deepClone = (obj) => obj ? JSON.parse(JSON.stringify(obj)) : obj;

        const buildBulletInstance = (opts, def) => {
            const base = deepClone(def || {});
            const collision = (opts && opts.collision) ? deepClone(opts.collision) : deepClone(def && def.collision);
            return Object.assign(base, opts || {}, { collision });
        };

        class BulletSim {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.bullets = [];
                this.player = { x: 300, y: 500, cooldown: 0 };
                this.keys = {};
                this.spawnLogic = null;
                this.behaviorLogic = null;
                this.activeBulletDef = null;
                this.time = 0;

                window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
            }

            setBulletDefinition(def) {
                this.activeBulletDef = def ? JSON.parse(JSON.stringify(def)) : null;
            }

            update(playerConfig) {
                this.time++;
                if (this.keys['arrowleft']) this.player.x -= playerConfig.speed;
                if (this.keys['arrowright']) this.player.x += playerConfig.speed;
                if (this.keys['arrowup']) this.player.y -= playerConfig.speed;
                if (this.keys['arrowdown']) this.player.y += playerConfig.speed;

                this.player.x = Math.max(10, Math.min(this.width - 10, this.player.x));
                this.player.y = Math.max(10, Math.min(this.height - 10, this.player.y));

                if (this.player.cooldown > 0) this.player.cooldown--;
                if (this.keys['z'] && this.player.cooldown <= 0) {
                    this.player.cooldown = playerConfig.fireRate;
                    this.executeSpawn();
                }

                // Update Bullets
                const ctx = {
                    getPlayerPosition: () => ({ x: this.player.x, y: this.player.y })
                };

                this.bullets.forEach(b => {
                    b._blockedByShield = false;
                    b.age++;
                    if (this.behaviorLogic) {
                        try {
                            this.behaviorLogic(b, this.time, ctx);
                        } catch (e) {
                            // Stop executing if error to prevent spam
                            this.behaviorLogic = null;
                            console.error("Runtime Error in Behavior:", e);
                        }
                    } else {
                        // Fallback
                        b.x += b.vx;
                        b.y += b.vy;
                    }
                });

                const playerCollider = this.getPlayerCollider();

                // Apply collision against player
                this.bullets.forEach(b => {
                    if (!b.collision || !b.collision.mask || !b.collision.mask.includes(GameData.Types.LAYER_PLAYER)) return;
                    if (this.checkOverlap(b, playerCollider)) {
                        const playerBehavior = playerCollider.collision && playerCollider.collision.behavior;
                        const shielded = playerBehavior && playerBehavior.type === GameData.Behaviors.DIRECTIONAL_SHIELD;
                        const allowImpact = !shielded || this.handleDirectionalShield(playerCollider, b, playerBehavior);
                        if (allowImpact && b.active !== false && !b._blockedByShield) {
                            this.resolveCollision(b, playerCollider);
                        }
                    }
                });

                // Terrain check (canvas bounds act as terrain for sim)
                this.bullets.forEach(b => {
                    if (!b.collision || !b.collision.mask || !b.collision.mask.includes(GameData.Types.LAYER_TERRAIN)) return;
                    if (this.checkOutOfBounds(b)) {
                        this.resolveTerrainCollision(b);
                    }
                });

                this.bullets = this.bullets.filter(b => b.active !== false && b.x > -40 && b.x < this.width + 40 && b.y > -40 && b.y < this.height + 40);
            }

            executeSpawn() {
                if (!this.spawnLogic) return;
                const ctx = {
                    spawn: (opts) => {
                        const base = this.createBulletFromDef(opts);
                        const angleRad = (opts.angle || -90) * Math.PI / 180;
                        const speed = opts.speed || base.speed || 4;
                        this.bullets.push(Object.assign(base, {
                            x: this.player.x,
                            y: this.player.y,
                            vx: Math.cos(angleRad) * speed,
                            vy: Math.sin(angleRad) * speed,
                            age: 0,
                            angle: 0 // For rotation
                        }));
                    }
                };
                try {
                    this.spawnLogic(this.player, this.time, ctx);
                    document.getElementById('bullet-debug').innerText = `Debug: Spawned at ${this.time}`;
                } catch (e) {
                    console.error("Runtime Error in Spawn:", e);
                    document.getElementById('bullet-debug').innerText = `Error: ${e.message}`;
                }
            }

            draw(playerConfig) {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.ctx.fillStyle = playerConfig.color || '#0ff';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x, this.player.y - 15);
                this.ctx.lineTo(this.player.x - 10, this.player.y + 10);
                this.ctx.lineTo(this.player.x + 10, this.player.y + 10);
                this.ctx.fill();

                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.color;
                    this.ctx.beginPath();
                    if (b.shape === 'star') {
                        const r = b.size;
                        for (let i = 0; i < 5; i++) {
                            const th = b.angle + i * Math.PI * 2 / 5;
                            const x = b.x + Math.cos(th) * r;
                            const y = b.y + Math.sin(th) * r;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.fill();
                    } else {
                        this.ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }

            // --- Collision Helpers (aligns with engine behaviors) ---
            getPlayerCollider() {
                const playerCollision = GameData.Library.Player && GameData.Library.Player.collision;
                return {
                    type: 'player',
                    x: this.player.x,
                    y: this.player.y,
                    collision: playerCollision ? JSON.parse(JSON.stringify(playerCollision)) : null,
                    radius: playerCollision && playerCollision.size ? playerCollision.size : 6
                };
            }

            createBulletFromDef(opts = {}, defOverride = null) {
                const def = defOverride || this.activeBulletDef || {};
                return buildBulletInstance({
                    type: def.type || GameData.Types.E_BULLET,
                    color: opts.color || def.color || '#ff0',
                    size: opts.size || def.radius || 4,
                    shape: opts.shape || def.shape || 'circle',
                    speed: opts.speed || def.speed,
                    collision: opts.collision || def.collision
                }, def);
            }

            checkOutOfBounds(b) {
                return b.x < 0 || b.x > this.width || b.y < 0 || b.y > this.height;
            }

            checkOverlap(a, b) {
                if (!a.collision || !b.collision) return false;
                const shapeA = a.collision.shape || 'circle';
                const shapeB = b.collision.shape || 'circle';

                const radiusA = Array.isArray(a.collision.size) ? Math.max(...a.collision.size) / 2 : (a.collision.size || a.size || 4);
                const radiusB = Array.isArray(b.collision.size) ? Math.max(...b.collision.size) / 2 : (b.collision.size || b.radius || 4);

                if (shapeA === 'circle' && shapeB === 'circle') {
                    const dx = a.x - b.x;
                    const dy = a.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < (radiusA + radiusB);
                }

                // Simple AABB fallback
                const aBox = {
                    left: a.x - radiusA,
                    right: a.x + radiusA,
                    top: a.y - radiusA,
                    bottom: a.y + radiusA
                };
                const bBox = {
                    left: b.x - radiusB,
                    right: b.x + radiusB,
                    top: b.y - radiusB,
                    bottom: b.y + radiusB
                };
                return !(aBox.right < bBox.left || aBox.left > bBox.right || aBox.bottom < bBox.top || aBox.top > bBox.bottom);
            }

            handleDirectionalShield(shield, other, behavior) {
                if (!other || !other.collision) return true;
                const direction = behavior.direction !== undefined ? behavior.direction : -Math.PI / 2;
                const arc = behavior.arc !== undefined ? behavior.arc : Math.PI / 2;

                const dx = (other.x || 0) - (shield.x || 0);
                const dy = (other.y || 0) - (shield.y || 0);
                const incoming = Math.atan2(dy, dx);
                const delta = Math.atan2(Math.sin(incoming - direction), Math.cos(incoming - direction));
                const withinShield = Math.abs(delta) <= arc / 2;

                if (!withinShield) return true;

                const response = behavior.response || 'reflect';
                if (response === 'reflect') {
                    this.reflectEntity(other, shield, behavior.reflect || behavior);
                    other._blockedByShield = true;
                } else if (response === 'absorb') {
                    other.active = false;
                    other._blockedByShield = true;
                }

                return false;
            }

            reflectEntity(entity, target, behavior) {
                if (!entity) return;
                const axis = behavior.axis || 'auto';
                let vx = entity.vx || 0;
                let vy = entity.vy || 0;
                const dampen = behavior.dampen !== undefined ? behavior.dampen : 1;

                const flipVelocity = (flipX, flipY) => {
                    if (flipX) vx = -vx;
                    if (flipY) vy = -vy;
                };

                if (axis === 'horizontal') {
                    flipVelocity(false, true);
                } else if (axis === 'vertical') {
                    flipVelocity(true, false);
                } else if (axis === 'both') {
                    flipVelocity(true, true);
                } else if (axis === 'auto' && target) {
                    const dx = entity.x - target.x;
                    const dy = entity.y - target.y;
                    flipVelocity(Math.abs(dx) > Math.abs(dy), Math.abs(dy) >= Math.abs(dx));
                } else {
                    flipVelocity(true, true);
                }

                entity.vx = vx * dampen;
                entity.vy = vy * dampen;
                if (behavior.maxBounces !== undefined) {
                    entity._bounces = (entity._bounces || 0) + 1;
                    if (entity._bounces > behavior.maxBounces) entity.active = false;
                }
            }

            splitEntity(entity, behavior) {
                const count = behavior.count || 3;
                if (!behavior.bullet) return;

                const spread = behavior.spread || Math.PI / 2;
                const speed = behavior.speed || Math.hypot(entity.vx || 0, entity.vy || 0) || 4;
                const baseAngle = behavior.baseAngle !== undefined ? behavior.baseAngle : Math.atan2(entity.vy || 0, entity.vx || 0);

                for (let i = 0; i < count; i++) {
                    const t = count === 1 ? 0 : (i / (count - 1) - 0.5);
                    const angle = baseAngle + t * spread;
                    const def = GameData.Library.Bullets[behavior.bullet] || {};
                    const bullet = this.createBulletFromDef({ ...def, speed }, def);
                    bullet.x = entity.x;
                    bullet.y = entity.y;
                    bullet.vx = Math.cos(angle) * speed;
                    bullet.vy = Math.sin(angle) * speed;
                    bullet.age = 0;
                    this.bullets.push(bullet);
                }

                entity.active = false;
            }

            resolveCollision(a, b) {
                const behavior = a.collision && a.collision.behavior;
                if (!behavior) return;

                let applyOnHit = true;

                if (behavior.type === GameData.Behaviors.DESTROY) {
                    a.active = false;
                } else if (behavior.type === GameData.Behaviors.PIERCE) {
                    if (behavior.pierce > 0) {
                        behavior.pierce--;
                    } else {
                        a.active = false;
                    }
                } else if (behavior.type === GameData.Behaviors.REFLECT) {
                    this.reflectEntity(a, b, behavior);
                } else if (behavior.type === GameData.Behaviors.SPLIT) {
                    this.splitEntity(a, behavior);
                } else if (behavior.type === GameData.Behaviors.DIRECTIONAL_SHIELD) {
                    applyOnHit = this.handleDirectionalShield(a, b, behavior);
                }

                if (applyOnHit && behavior.onHit) {
                    // Minimal feedback for simulator
                    document.getElementById('bullet-debug').innerText = `Hit detected at ${this.time}`;
                }
            }

            resolveTerrainCollision(entity) {
                if (!entity.collision || !entity.collision.behavior) return;
                const behavior = entity.collision.behavior;
                if (behavior.type === GameData.Behaviors.DESTROY) {
                    entity.active = false;
                } else if (behavior.type === GameData.Behaviors.PIERCE) {
                    if (behavior.pierce > 0) {
                        behavior.pierce--;
                    } else {
                        entity.active = false;
                    }
                } else if (behavior.type === GameData.Behaviors.REFLECT) {
                    const inferred = { ...behavior };
                    if (!behavior.axis) {
                        const hitSideX = entity.x < 0 || entity.x > this.width;
                        const hitSideY = entity.y < 0 || entity.y > this.height;
                        inferred.axis = hitSideX && hitSideY ? 'both' : (hitSideX ? 'vertical' : 'horizontal');
                    }
                    this.reflectEntity(entity, null, inferred);
                    entity.x = Math.max(0, Math.min(this.width, entity.x));
                    entity.y = Math.max(0, Math.min(this.height, entity.y));
                } else if (behavior.type === GameData.Behaviors.SPLIT) {
                    this.splitEntity(entity, behavior);
                }
            }
        }

        /**
         * ============================================================================
         * MODULE 4: ENEMY SIMULATOR (Uses GameData.Library.Enemies)
         * ============================================================================
         */
        class EnemySim {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.enemy = null;
                this.bullets = [];
                this.particles = [];
                this.aiFunction = null;
                this.age = 0;
                this.player = { x: this.width / 2, y: this.height - 100, hp: 3, active: true, hitTimer: 0 };
                this.playerConfig = {};
            }

            reset(config, aiCode, playerConfig) {
                this.enemy = {
                    world: { x: this.width / 2, y: 100 },
                    local: { x: 0, y: 0, angle: 0 },
                    age: 0,
                    hp: config.hp || 50,
                    radius: config.radius || 20,
                    color: config.color || '#f00',
                    score: config.score || 0
                };
                this.bullets = [];
                this.particles = [];
                this.age = 0;
                this.setPlayerConfig(playerConfig || this.playerConfig);

                // Compile AI
                try {
                    this.aiFunction = new Function('me', 'ctx', aiCode);
                } catch (e) { console.error(e); }
            }

            setPlayerConfig(cfg = {}) {
                this.playerConfig = cfg;
                const basePlayer = GameData.Library.Player || {};
                this.player.color = cfg.color || basePlayer.color || '#0ff';
                this.player.hp = cfg.hp || 3;
                this.player.radius = cfg.radius || basePlayer.radius || 10;
                this.player.collision = deepClone((basePlayer && basePlayer.collision) || {});
                this.player.active = true;
            }

            getPlayerCollider() {
                return {
                    type: 'player',
                    x: this.player.x,
                    y: this.player.y,
                    collision: deepClone(GameData.Library.Player && GameData.Library.Player.collision),
                    radius: (GameData.Library.Player && GameData.Library.Player.collision && GameData.Library.Player.collision.size) || 6
                };
            }

            createBulletFromDef(opts = {}, defOverride = null) {
                const def = defOverride || {};
                return buildBulletInstance({
                    type: def.type || GameData.Types.E_BULLET,
                    color: opts.color || def.color || '#ff0',
                    size: opts.size || def.radius || 4,
                    shape: opts.shape || def.shape || 'circle',
                    speed: opts.speed || def.speed,
                    collision: opts.collision || def.collision
                }, def);
            }

            update(playerConfig) {
                if (playerConfig) this.setPlayerConfig(playerConfig);
                if (!this.enemy || !this.aiFunction) return;

                this.enemy.age++;
                this.age++;

                const mockCtx = {
                    getPlayerPosition: () => ({ x: this.width / 2, y: this.height - 100 }),
                    spawn: (type, x, y, opts = {}) => {
                        const def = (typeof type === 'string') ? GameData.Library.Bullets[type] : (type && GameData.Library.Bullets[type.type]);
                        const merged = Object.assign({}, opts, typeof type === 'object' ? type : null);
                        const base = this.createBulletFromDef(merged, def);
                        const angle = merged.angle !== undefined ? merged.angle * Math.PI / 180 : null;
                        const speed = merged.speed || base.speed || Math.hypot(merged.vx || 0, merged.vy || 0) || 4;
                        base.x = x; base.y = y; base.age = 0;
                        base.vx = angle !== null ? Math.cos(angle) * speed : (merged.vx || def?.vx || 0);
                        base.vy = angle !== null ? Math.sin(angle) * speed : (merged.vy || def?.vy || 0);
                        this.bullets.push(base);
                    },
                    spawnEnemy: (id, x, y) => {
                        // Mock spawn enemy (visualize as particle for now)
                        this.particles.push({ x: x, y: y, vx: 0, vy: 0, life: 60, color: '#fff' });
                    },
                    spawnParticle: (x, y, color, count) => {
                        for (let i = 0; i < count; i++) {
                            this.particles.push({
                                x: x, y: y,
                                vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                                life: 30, color: color
                            });
                        }
                    }
                };

                try {
                    this.aiFunction(this.enemy, mockCtx);
                } catch (e) { }

                // Sync World/Local (simplified)
                if (this.enemy.age === 1) {
                    this.enemy.local.x = this.enemy.world.x;
                    this.enemy.local.y = this.enemy.world.y;
                }
                this.enemy.world.x = this.enemy.local.x;
                this.enemy.world.y = this.enemy.local.y;

                this.bullets.forEach(b => {
                    b._blockedByShield = false;
                    b.x += b.vx; b.y += b.vy;
                });

                const playerCollider = this.getPlayerCollider();
                this.bullets.forEach(b => {
                    if (!b.collision || !b.collision.mask || !b.collision.mask.includes(GameData.Types.LAYER_PLAYER)) return;
                    if (this.checkOverlap(b, playerCollider)) {
                        const playerBehavior = playerCollider.collision && playerCollider.collision.behavior;
                        const shielded = playerBehavior && playerBehavior.type === GameData.Behaviors.DIRECTIONAL_SHIELD;
                        const allowImpact = !shielded || this.handleDirectionalShield(playerCollider, b, playerBehavior);
                        if (allowImpact && b.active !== false && !b._blockedByShield) {
                            this.resolveCollision(b, playerCollider);
                            if (this.player.active) {
                                this.player.hp -= (b.power || 1);
                                this.player.hitTimer = 6;
                                if (this.player.hp <= 0) this.player.active = false;
                            }
                        }
                    }
                });

                this.bullets.forEach(b => {
                    if (!b.collision || !b.collision.mask || !b.collision.mask.includes(GameData.Types.LAYER_TERRAIN)) return;
                    if (b.x < 0 || b.x > this.width || b.y < 0 || b.y > this.height) {
                        this.resolveTerrainCollision(b);
                    }
                });

                this.bullets = this.bullets.filter(b => b.active !== false && b.x > -40 && b.x < this.width + 40 && b.y > -40 && b.y < this.height + 40);

                this.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw(playerConfig) {
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.ctx.strokeStyle = '#333';
                this.ctx.beginPath();
                this.ctx.arc(this.width / 2, this.height - 100, this.player.radius || 10, 0, Math.PI * 2);
                this.ctx.stroke();

                if (this.enemy) {
                    this.ctx.save();
                    this.ctx.translate(this.enemy.world.x, this.enemy.world.y);
                    this.ctx.rotate(this.enemy.local.angle || 0);
                    this.ctx.fillStyle = this.enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, this.enemy.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(0, -2, this.enemy.radius, 4);
                    this.ctx.restore();
                }

                if (this.player.active) {
                    this.ctx.fillStyle = (this.player.hitTimer > 0) ? '#f88' : (playerConfig && playerConfig.color) || this.player.color;
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, this.player.radius || 10, 0, Math.PI * 2);
                    this.ctx.fill();
                    if (this.player.hitTimer > 0) this.player.hitTimer--;
                }

                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.color;
                    this.ctx.beginPath();
                    const radius = b.radius || b.size || (b.collision && b.collision.size) || 4;
                    this.ctx.arc(b.x, b.y, Array.isArray(radius) ? Math.max(...radius) / 2 : radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.fillRect(p.x, p.y, 2, 2);
                });
            }
        }

        ['checkOverlap', 'handleDirectionalShield', 'reflectEntity', 'splitEntity', 'resolveCollision', 'resolveTerrainCollision'].forEach(fn => {
            EnemySim.prototype[fn] = BulletSim.prototype[fn];
        });

        EnemySim.prototype.resolveCollision = function (a, b) {
            if (!a.collision || !a.collision.behavior) return;
            const behavior = a.collision.behavior;
            let applyOnHit = true;

            if (behavior.type === GameData.Behaviors.DESTROY) {
                a.active = false;
            } else if (behavior.type === GameData.Behaviors.PIERCE) {
                if (behavior.pierce > 0) {
                    behavior.pierce--;
                } else {
                    a.active = false;
                }
            } else if (behavior.type === GameData.Behaviors.REFLECT) {
                this.reflectEntity(a, b, behavior);
            } else if (behavior.type === GameData.Behaviors.SPLIT) {
                this.splitEntity(a, behavior);
            } else if (behavior.type === GameData.Behaviors.DIRECTIONAL_SHIELD) {
                applyOnHit = this.handleDirectionalShield(a, b, behavior);
            }

            if (applyOnHit && behavior.onHit) {
                // Enemy simulator currently omits damage resolution details
            }
        };

        const App = {
            views: {},
            state: {
                scrollY: 0,
                activeTab: 'editor',
                terrainConfig: {},
                noiseConfig: {},
                playerConfig: {},
                bulletConfig: {},
                enemyConfig: {}
            },

            init() {
                this.noiseGen = new NoiseGenerator();
                this.terrainSys = new TerrainSystem(this.noiseGen);
                this.views.terrain = new Visualizer('canvas-terrain');
                this.views.noise = new Visualizer('canvas-noise');
                this.bulletSim = new BulletSim('canvas-bullet');
                this.enemySim = new EnemySim('canvas-enemy');

                document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(btn.dataset.target).classList.add('active');
                    this.state.activeTab = btn.dataset.target;
                }));

                this.initTerrainUI();
                this.initNoiseUI();
                this.initBulletUI();
                this.initEnemyUI();

                requestAnimationFrame(t => this.loop(t));
            },

            initTerrainUI() {
                const sel = document.getElementById('terrain-preset');
                const txt = document.getElementById('input-terrain');

                // Load from GameData.Library.Terrains
                Object.keys(GameData.Library.Terrains).forEach(k => sel.add(new Option(k, k)));

                const load = () => {
                    this.state.terrainConfig = JSON.parse(JSON.stringify(GameData.Library.Terrains[sel.value]));
                    txt.value = JSON.stringify(this.state.terrainConfig, null, 4);
                };
                sel.addEventListener('change', load);
                document.getElementById('btn-apply-terrain').addEventListener('click', () => {
                    try { this.state.terrainConfig = JSON.parse(txt.value); } catch (e) { }
                });
                if (sel.options.length > 0) load();
            },

            initNoiseUI() {
                const sel = document.getElementById('select-algo');
                const txt = document.getElementById('input-noise');
                const editor = document.getElementById('code-editor');
                const status = document.getElementById('compile-status');

                const refreshList = () => {
                    const current = sel.value;
                    sel.innerHTML = '';
                    // Load from GameData.Library.Noise
                    Object.keys(GameData.Library.Noise).forEach(k => sel.add(new Option(k, k)));
                    if (current && GameData.Library.Noise[current]) sel.value = current;
                };
                refreshList();

                const updateView = () => {
                    const name = sel.value;
                    this.state.noiseConfig = { scale: 8, speed: 1.0, colorize: false };
                    txt.value = JSON.stringify(this.state.noiseConfig, null, 4);
                    editor.value = this.noiseGen.getSourceBody(name);
                    editor.classList.remove('error');
                    status.innerText = "AST: Ready to parse.";
                    status.className = "status-msg status-ok";
                };

                const apply = () => {
                    try {
                        this.state.noiseConfig = JSON.parse(txt.value);
                        this.noiseGen.replace(sel.value, editor.value);
                        editor.classList.remove('error');
                        status.innerText = "AST: Valid Syntax. Compiled Successfully.";
                        status.className = "status-msg status-ok";
                    } catch (e) {
                        editor.classList.add('error');
                        status.innerText = e.message;
                        status.className = "status-msg status-err";
                    }
                };

                sel.addEventListener('change', updateView);
                document.getElementById('btn-apply-noise').addEventListener('click', apply);
                updateView();
            },

            initBulletUI() {
                const sel = document.getElementById('select-bullet');
                const spawnEditor = document.getElementById('input-bullet-config');
                const behaviorEditor = document.getElementById('input-bullet-behavior');
                const status = document.getElementById('bullet-compile-status');
                const pTxt = document.getElementById('input-player-config');

                Object.keys(GameData.Library.Bullets).forEach(k => sel.add(new Option(k, k)));

                const load = () => {
                    const def = GameData.Library.Bullets[sel.value];
                    if (!def) return;
                    this.bulletSim.setBulletDefinition(def);

                    spawnEditor.value = `// Spawn Script for ${sel.value}
    ctx.spawn({
        speed: ${def.speed || 6},
        angle: -90,
        color: '${def.color || '#ff0'}',
        size: ${def.radius || 4}
    });`;

                    behaviorEditor.value = def.behavior || "b.x += b.vx;\nb.y += b.vy;";

                    apply();
                };

                const apply = () => {
                    status.className = "status-msg";
                    status.innerText = "Compiling...";

                    try {
                        this.state.playerConfig = JSON.parse(pTxt.value);
                    } catch (e) { }

                    const spawnCheck = CodeParser.validate(spawnEditor.value, 'p, t, ctx');
                    if (!spawnCheck.valid) {
                        status.className = "status-msg status-err";
                        status.innerText = `Spawn Error: ${spawnCheck.message}`;
                        spawnEditor.classList.add('error');
                        return;
                    }
                    spawnEditor.classList.remove('error');

                    const behaviorCheck = CodeParser.validate(behaviorEditor.value, 'b, t, ctx');
                    if (!behaviorCheck.valid) {
                        status.className = "status-msg status-err";
                        status.innerText = `Behavior Error: ${behaviorCheck.message}`;
                        behaviorEditor.classList.add('error');
                        return;
                    }
                    behaviorEditor.classList.remove('error');

                    try {
                        this.bulletSim.spawnLogic = new Function('p', 't', 'ctx', spawnEditor.value);
                        this.bulletSim.behaviorLogic = new Function('b', 't', 'ctx', behaviorEditor.value);
                        status.className = "status-msg status-ok";
                        status.innerText = "AST: Valid Syntax. Compiled Successfully.";
                    } catch (e) {
                        status.className = "status-msg status-err";
                        status.innerText = `Runtime Compile Error: ${e.message}`;
                    }
                };

                document.getElementById('btn-load-bullet').addEventListener('click', load);
                document.getElementById('btn-apply-bullet').addEventListener('click', apply);
                sel.addEventListener('change', load);

                if (sel.options.length > 0) load();
            },

            initEnemyUI() {
                const sel = document.getElementById('select-enemy');
                const cTxt = document.getElementById('input-enemy-config');
                const aiTxt = document.getElementById('input-enemy-ai');
                const status = document.getElementById('enemy-compile-status');

                Object.keys(GameData.Library.Enemies).forEach(k => sel.add(new Option(k, k)));

                const load = () => {
                    const def = GameData.Library.Enemies[sel.value];
                    if (!def) return;
                    const config = { hp: def.hp, radius: def.radius, color: def.color, score: def.score };
                    cTxt.value = JSON.stringify(config, null, 4);
                    aiTxt.value = CodeParser.extractBody(def.ai.toString());
                    apply();
                };

                const apply = () => {
                    try {
                        this.state.enemyConfig = JSON.parse(cTxt.value);
                        const check = CodeParser.validate(aiTxt.value, 'me, ctx');
                        if (!check.valid) throw new Error(`Syntax Error: ${check.message}`);

                        status.innerText = "AST: Valid Syntax. AI Updated.";
                        status.className = "status-msg status-ok";
                        aiTxt.classList.remove('error');

                        this.enemySim.reset(this.state.enemyConfig, aiTxt.value, this.state.playerConfig);
                    } catch (e) {
                        status.innerText = e.message;
                        status.className = "status-msg status-err";
                        aiTxt.classList.add('error');
                    }
                };

                document.getElementById('btn-load-enemy').addEventListener('click', load);
                document.getElementById('btn-apply-enemy').addEventListener('click', apply);
                document.getElementById('btn-reset-enemy').addEventListener('click', () => {
                    this.enemySim.reset(this.state.enemyConfig, aiTxt.value, this.state.playerConfig);
                });

                if (sel.options.length > 0) load();
            },

            loop(t) {
                const time = t * 0.001;

                if (this.state.activeTab === 'editor') {
                    this.state.scrollY -= 2;
                    this.views.terrain.drawTerrain(this.terrainSys, this.state.terrainConfig, this.state.scrollY);
                } else if (this.state.activeTab === 'gallery') {
                    this.views.noise.drawNoise(this.noiseGen, document.getElementById('select-algo').value, this.state.noiseConfig, time);
                } else if (this.state.activeTab === 'bullet-sim') {
                    this.bulletSim.update(this.state.playerConfig);
                    this.bulletSim.draw(this.state.playerConfig);
                } else if (this.state.activeTab === 'enemy-sim') {
                    this.enemySim.update(this.state.playerConfig);
                    this.enemySim.draw(this.state.playerConfig);
                }

                requestAnimationFrame(t => this.loop(t));
            }
        };

        App.init();
    </script>
</body>

</html>