<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Unified Game Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/acorn/8.11.3/acorn.min.js"></script>
    <style>
        :root {
            --bg: #111;
            --panel: #1a1a1a;
            --border: #333;
            --accent: #0066cc;
            --error: #cc3300;
            --text: #eee;
            --code: #aaddff;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Consolas', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Layout */
        #header {
            background: #222;
            padding: 0 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 2px;
        }

        .tab-btn {
            background: #333;
            border: none;
            color: #888;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            margin-top: 5px;
            border-radius: 5px 5px 0 0;
            transition: 0.2s;
        }

        .tab-btn.active {
            background: #444;
            color: #fff;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            flex: 1;
            height: calc(100vh - 40px);
            overflow: hidden;
        }

        .tab-content.active {
            display: flex;
        }

        /* UI Components */
        .pane-sidebar {
            width: 450px;
            background: var(--panel);
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border);
            padding: 10px;
            overflow-y: auto;
        }

        .pane-preview {
            flex: 1;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        textarea {
            background: #111;
            color: #0f0;
            border: 1px solid var(--border);
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            resize: none;
            line-height: 1.4;
            tab-size: 4;
            outline: none;
        }

        .code-editor {
            background: #0d1117;
            color: #e6edf3;
            border: 1px solid #30363d;
            flex: 1;
            min-height: 200px;
            white-space: pre;
            overflow-x: auto;
            font-size: 12px;
        }

        .code-editor:focus {
            border-color: var(--accent);
        }

        .code-editor.error {
            border-color: var(--error);
            background: #1a0505;
        }

        h3 {
            margin: 15px 0 5px;
            font-size: 14px;
            color: #aaa;
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
        }

        select,
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px;
            cursor: pointer;
            font-family: inherit;
        }

        button.primary {
            background: var(--accent);
            border-color: #0088ff;
        }

        .row {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }

        .flex-1 {
            flex: 1;
        }

        .status-msg {
            font-size: 11px;
            margin-top: 5px;
            min-height: 1.4em;
        }

        .status-ok {
            color: #0f0;
        }

        .status-err {
            color: #f55;
        }

        .tip {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <div id="header">
        <button class="tab-btn active" data-target="editor">1. Terrain Editor</button>
        <button class="tab-btn" data-target="gallery">2. Noise Lab</button>
        <button class="tab-btn" data-target="bullet-sim">3. Bullet Sim</button>
        <button class="tab-btn" data-target="enemy-sim">4. Enemy Sim</button>
    </div>

    <!-- TAB 1: Terrain Editor -->
    <div id="editor" class="tab-content active">
        <div class="pane-sidebar">
            <h3>Terrain Presets (Global Library)</h3>
            <div class="row">
                <select id="terrain-preset" class="flex-1"></select>
                <button class="primary" id="btn-apply-terrain">Apply</button>
            </div>
            <textarea id="input-terrain" spellcheck="false" class="flex-1"></textarea>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-terrain" width="600" height="800"></canvas>
        </div>
    </div>

    <!-- TAB 2: Noise Lab -->
    <div id="gallery" class="tab-content">
        <div class="pane-sidebar">
            <h3>Algorithm Selection (Global Library)</h3>
            <div class="row">
                <select id="select-algo" class="flex-1"></select>
            </div>

            <h3>Parameters</h3>
            <textarea id="input-noise" spellcheck="false" style="height:80px; min-height:80px; color:#8f8;"></textarea>

            <h3>Source Code (Live AST Parsing)</h3>
            <textarea id="code-editor" class="code-editor" spellcheck="false"></textarea>

            <div id="compile-status" class="status-msg status-ok">Ready.</div>
            <button class="primary" id="btn-apply-noise" style="width:100%; margin-top:5px; height: 40px;">
                AST CHECK & COMPILE
            </button>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-noise" width="600" height="600"></canvas>
        </div>
    </div>

    <!-- TAB 3: Bullet Simulator -->
    <div id="bullet-sim" class="tab-content">
        <div class="pane-sidebar">
            <h3>Player Config</h3>
            <textarea id="input-player-config" spellcheck="false" style="height:100px; color:#8f8;">{
    "speed": 4,
    "fireRate": 5,
    "color": "#0ff"
}</textarea>

            <h3>Bullet Selection (Global Library)</h3>
            <div class="row">
                <select id="select-bullet" class="flex-1"></select>
                <button class="primary" id="btn-load-bullet">Load</button>
            </div>

            <h3>Bullet Config (Spawn Script)</h3>
            <textarea id="input-bullet-config" class="code-editor" spellcheck="false" style="height:120px;">
            // Spiral Pattern
            const count = 5;
            for(let i=0; i<count; i++) {
                ctx.spawn({
                    speed: 4,
                    angle: (t * 5) + (i * (360/count)),
                    color: '#ff0'
                });
            }</textarea>

            <h3>Bullet Behavior (Trajectory Script)</h3>
            <textarea id="input-bullet-behavior" class="code-editor" spellcheck="false"
                style="height:100px;"></textarea>

            <div id="bullet-compile-status" class="status-msg status-ok">Ready.</div>
            <div id="bullet-debug" class="status-msg" style="color:#aaa;">Debug: Waiting...</div>
            <button class="primary" id="btn-apply-bullet">Apply Config</button>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-bullet" width="600" height="600"></canvas>
        </div>
    </div>

    <!-- TAB 4: Enemy Simulator -->
    <div id="enemy-sim" class="tab-content">
        <div class="pane-sidebar">
            <h3>Enemy Selection (Global Library)</h3>
            <div class="row">
                <select id="select-enemy" class="flex-1"></select>
                <button class="primary" id="btn-load-enemy">Load</button>
            </div>

            <h3>Enemy Config</h3>
            <textarea id="input-enemy-config" spellcheck="false" style="height:100px; color:#8f8;"></textarea>

            <h3>AI Logic (AST Parsed)</h3>
            <textarea id="input-enemy-ai" class="code-editor" spellcheck="false"></textarea>

            <div id="enemy-compile-status" class="status-msg status-ok">Ready.</div>
            <button class="primary" id="btn-apply-enemy">AST CHECK & COMPILE</button>
            <button id="btn-reset-enemy" style="margin-top:5px;">Reset Enemy</button>
        </div>
        <div class="pane-preview">
            <canvas id="canvas-enemy" width="600" height="600"></canvas>
        </div>
    </div>

    <!-- LOAD UNIFIED DATA -->
    <script src="utils.js"></script>
    <script src="data/core.js"></script>
    <script src="data/library/noise.js"></script>
    <script src="data/library/terrains.js"></script>
    <script src="data/library/enemies.js"></script>
    <script src="data/library/bullets.js"></script>
    <script src="data/library/bosses.js"></script>
    <script src="data/library/scripts.js"></script>

    <script>
        /**
         * ============================================================================
         * MODULE 0: AST PARSER HELPER
         * ============================================================================
         */
        class CodeParser {
            static extractBody(fnString) {
                if (!window.acorn) return this.fallbackExtract(fnString);
                try {
                    let codeToParse = fnString.trim();
                    if (!codeToParse.startsWith('function') && !codeToParse.startsWith('(')) {
                        codeToParse = 'function ' + codeToParse;
                    }
                    const ast = acorn.parse(codeToParse, { ecmaVersion: 2020 });
                    let bodyNode = null;
                    const walk = (node) => {
                        if (bodyNode) return;
                        if (node.type === 'BlockStatement') { bodyNode = node; return; }
                        for (const key in node) {
                            if (node[key] && typeof node[key] === 'object') {
                                if (Array.isArray(node[key])) node[key].forEach(walk);
                                else walk(node[key]);
                            }
                        }
                    };
                    walk(ast);
                    if (bodyNode) return codeToParse.substring(bodyNode.start + 1, bodyNode.end - 1).trim();
                } catch (e) { console.warn("AST Fallback"); }
                return this.fallbackExtract(fnString);
            }
            static validate(bodyCode, args) {
                if (!window.acorn) return { valid: true };
                const wrapped = `function check(${args}) { ${bodyCode} }`;
                try {
                    acorn.parse(wrapped, { ecmaVersion: 2020 });
                    return { valid: true };
                } catch (e) {
                    return { valid: false, message: e.message, pos: Math.max(0, e.pos - (16 + args.length)) };
                }
            }
            static fallbackExtract(str) {
                const s = str.indexOf('{'), e = str.lastIndexOf('}');
                return (s === -1 || e === -1) ? str : str.substring(s + 1, e).trim();
            }
        }

        /**
         * ============================================================================
         * MODULE 1: NOISE GENERATOR (Uses GameData.Library.Noise)
         * ============================================================================
         */
        class NoiseGenerator {
            constructor() {
                // Wrapper to access GameData.Library.Noise
            }
            get(name) {
                return GameData.Library.Noise[name] || GameData.Library.Noise.value;
            }
            getSourceBody(name) {
                const fn = GameData.Library.Noise[name];
                if (!fn) return "// No source available";
                return CodeParser.extractBody(fn.toString());
            }
            replace(name, bodyStr) {
                const check = CodeParser.validate(bodyStr, 'x, y, t, M, N');
                if (!check.valid) throw new Error(`Syntax Error at char ${check.pos}: ${check.message}`);
                const fn = new Function('x', 'y', 't', 'M', 'N', bodyStr);
                // Update Global Library
                GameData.registerNoise(name, fn);
                return true;
            }
        }

        /**
         * ============================================================================
         * MODULE 2: TERRAIN SYSTEM (Uses GameData.Library.Terrains)
         * ============================================================================
         */
        class TerrainSystem {
            constructor(noiseGen) { this.noise = noiseGen; }
            evaluate(x, y, width, config) {
                if (config.Walls) {
                    let limitL = 0, limitR = width;
                    for (const w of config.Walls) {
                        const val = Math.sin(y * w.freq) * w.amp + w.offset;
                        if (w.side === 'left') limitL = Math.max(limitL, val);
                        if (w.side === 'right') limitR = Math.min(limitR, width - val);
                    }
                    if (config.Walls.find(w => w.side === 'left') && x < limitL) return { type: 'wall', color: config.Walls.find(w => w.side === 'left').color };
                    if (config.Walls.find(w => w.side === 'right') && x > limitR) return { type: 'wall', color: config.Walls.find(w => w.side === 'right').color };
                }
                if (config.Ground) {
                    const g = config.Ground;
                    const fn = this.noise.get(g.type);
                    const n = fn(x * g.scale, y * g.scale);
                    if (n > g.threshold) return { type: 'ground', color: g.color };
                }
                if (config.Background) {
                    const b = config.Background;
                    const fn = this.noise.get(b.type);
                    const n = fn(x * b.scale, y * b.scale);
                    if (n > b.threshold) return { type: 'bg', color: b.color };
                }
                return { type: 'none', color: null };
            }
        }

        class Visualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
            }
            drawTerrain(sys, config, scrollY) {
                this.ctx.fillStyle = config.clearColor || '#000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                const DOT = 4;
                const rows = Math.ceil(this.height / DOT), cols = Math.ceil(this.width / DOT);
                for (let r = 0; r < rows; r++) {
                    const y = r * DOT;
                    const worldY = y - scrollY;
                    for (let c = 0; c < cols; c++) {
                        const x = c * DOT;
                        const res = sys.evaluate(x, worldY, this.width, config);
                        if (res.type !== 'none') {
                            this.ctx.fillStyle = res.color;
                            this.ctx.fillRect(x, y, DOT, DOT);
                        }
                    }
                }
            }
            drawNoise(gen, algo, params, time) {
                const idata = this.ctx.createImageData(this.width, this.height);
                const data = idata.data;
                const fn = gen.get(algo);
                const scale = params.scale || 8;
                // Pass GameData.NoiseMath as context
                const M = Math;
                const N = GameData.NoiseMath;

                for (let py = 0; py < this.height; py++) {
                    for (let px = 0; px < this.width; px++) {
                        const x = px / (this.width / scale);
                        const y = py / (this.height / scale);
                        let val = fn(x, y + time, M, N);
                        val = Math.max(0, Math.min(1, val));
                        const c = Math.floor(val * 255);
                        const idx = (px + py * this.width) * 4;
                        if (params.colorize) {
                            data[idx] = c; data[idx + 1] = 255 - c; data[idx + 2] = c / 2; data[idx + 3] = 255;
                        } else {
                            data[idx] = c; data[idx + 1] = c; data[idx + 2] = c; data[idx + 3] = 255;
                        }
                    }
                }
                this.ctx.putImageData(idata, 0, 0);
            }
        }

        /**
         * ============================================================================
         * MODULE 3: BULLET SIMULATOR
         * ============================================================================
         */
        class BulletSim {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.bullets = [];
                this.player = { x: 300, y: 500, cooldown: 0 };
                this.keys = {};
                this.spawnLogic = null;
                this.behaviorLogic = null;
                this.time = 0;

                window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
            }

            update(playerConfig) {
                this.time++;
                if (this.keys['arrowleft']) this.player.x -= playerConfig.speed;
                if (this.keys['arrowright']) this.player.x += playerConfig.speed;
                if (this.keys['arrowup']) this.player.y -= playerConfig.speed;
                if (this.keys['arrowdown']) this.player.y += playerConfig.speed;

                this.player.x = Math.max(10, Math.min(this.width - 10, this.player.x));
                this.player.y = Math.max(10, Math.min(this.height - 10, this.player.y));

                if (this.player.cooldown > 0) this.player.cooldown--;
                if (this.keys['z'] && this.player.cooldown <= 0) {
                    this.player.cooldown = playerConfig.fireRate;
                    this.executeSpawn();
                }

                // Update Bullets
                const ctx = {
                    getPlayerPosition: () => ({ x: this.player.x, y: this.player.y })
                };

                this.bullets.forEach(b => {
                    b.age++;
                    if (this.behaviorLogic) {
                        try {
                            this.behaviorLogic(b, this.time, ctx);
                        } catch (e) {
                            // Stop executing if error to prevent spam
                            this.behaviorLogic = null;
                            console.error("Runtime Error in Behavior:", e);
                        }
                    } else {
                        // Fallback
                        b.x += b.vx;
                        b.y += b.vy;
                    }
                });
                this.bullets = this.bullets.filter(b => b.x > 0 && b.x < this.width && b.y > 0 && b.y < this.height);
            }

            executeSpawn() {
                if (!this.spawnLogic) return;
                const ctx = {
                    spawn: (opts) => {
                        const angleRad = (opts.angle || -90) * Math.PI / 180;
                        const speed = opts.speed || 4;
                        this.bullets.push({
                            x: this.player.x,
                            y: this.player.y,
                            vx: Math.cos(angleRad) * speed,
                            vy: Math.sin(angleRad) * speed,
                            color: opts.color || '#ff0',
                            size: opts.size || 4,
                            age: 0,
                            angle: 0 // For rotation
                        });
                    }
                };
                try {
                    this.spawnLogic(this.player, this.time, ctx);
                    document.getElementById('bullet-debug').innerText = `Debug: Spawned at ${this.time}`;
                } catch (e) {
                    console.error("Runtime Error in Spawn:", e);
                    document.getElementById('bullet-debug').innerText = `Error: ${e.message}`;
                }
            }

            draw(playerConfig) {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.ctx.fillStyle = playerConfig.color || '#0ff';
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x, this.player.y - 15);
                this.ctx.lineTo(this.player.x - 10, this.player.y + 10);
                this.ctx.lineTo(this.player.x + 10, this.player.y + 10);
                this.ctx.fill();

                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.color;
                    this.ctx.beginPath();
                    if (b.shape === 'star') {
                        const r = b.size;
                        for (let i = 0; i < 5; i++) {
                            const th = b.angle + i * Math.PI * 2 / 5;
                            const x = b.x + Math.cos(th) * r;
                            const y = b.y + Math.sin(th) * r;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                        this.ctx.fill();
                    } else {
                        this.ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
        }

        /**
         * ============================================================================
         * MODULE 4: ENEMY SIMULATOR (Uses GameData.Library.Enemies)
         * ============================================================================
         */
        class EnemySim {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                this.enemy = null;
                this.bullets = [];
                this.particles = [];
                this.aiFunction = null;
                this.age = 0;
            }

            reset(config, aiCode) {
                this.enemy = {
                    world: { x: this.width / 2, y: 100 },
                    local: { x: 0, y: 0, angle: 0 },
                    age: 0,
                    hp: config.hp || 50,
                    radius: config.radius || 20,
                    color: config.color || '#f00',
                    score: config.score || 0
                };
                this.bullets = [];
                this.particles = [];
                this.age = 0;

                // Compile AI
                try {
                    this.aiFunction = new Function('me', 'ctx', aiCode);
                } catch (e) { console.error(e); }
            }

            update() {
                if (!this.enemy || !this.aiFunction) return;

                this.enemy.age++;
                this.age++;

                const mockCtx = {
                    getPlayerPosition: () => ({ x: this.width / 2, y: this.height - 100 }),
                    spawn: (type, x, y, opts) => {
                        this.bullets.push({
                            x: x, y: y,
                            vx: opts.vx || 0, vy: opts.vy || 0,
                            radius: opts.radius || 4,
                            color: opts.color || '#ff0'
                        });
                    },
                    spawnEnemy: (id, x, y) => {
                        // Mock spawn enemy (visualize as particle for now)
                        this.particles.push({ x: x, y: y, vx: 0, vy: 0, life: 60, color: '#fff' });
                    },
                    spawnParticle: (x, y, color, count) => {
                        for (let i = 0; i < count; i++) {
                            this.particles.push({
                                x: x, y: y,
                                vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5,
                                life: 30, color: color
                            });
                        }
                    }
                };

                try {
                    this.aiFunction(this.enemy, mockCtx);
                } catch (e) { }

                // Sync World/Local (simplified)
                if (this.enemy.age === 1) {
                    this.enemy.local.x = this.enemy.world.x;
                    this.enemy.local.y = this.enemy.world.y;
                }
                this.enemy.world.x = this.enemy.local.x;
                this.enemy.world.y = this.enemy.local.y;

                this.bullets.forEach(b => { b.x += b.vx; b.y += b.vy; });
                this.bullets = this.bullets.filter(b => b.x > 0 && b.x < this.width && b.y > 0 && b.y < this.height);

                this.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; });
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw() {
                this.ctx.fillStyle = '#111';
                this.ctx.fillRect(0, 0, this.width, this.height);

                this.ctx.strokeStyle = '#333';
                this.ctx.beginPath();
                this.ctx.arc(this.width / 2, this.height - 100, 10, 0, Math.PI * 2);
                this.ctx.stroke();

                if (this.enemy) {
                    this.ctx.save();
                    this.ctx.translate(this.enemy.world.x, this.enemy.world.y);
                    this.ctx.rotate(this.enemy.local.angle || 0);
                    this.ctx.fillStyle = this.enemy.color;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, this.enemy.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(0, -2, this.enemy.radius, 4);
                    this.ctx.restore();
                }

                this.bullets.forEach(b => {
                    this.ctx.fillStyle = b.color;
                    this.ctx.beginPath();
                    this.ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color;
                    this.ctx.fillRect(p.x, p.y, 2, 2);
                });
            }
        }

        const App = {
            views: {},
            state: {
                scrollY: 0,
                activeTab: 'editor',
                terrainConfig: {},
                noiseConfig: {},
                playerConfig: {},
                bulletConfig: {},
                enemyConfig: {}
            },

            init() {
                this.terrainSys = new TerrainSystem(this.noiseGen);
                this.views.terrain = new Visualizer('canvas-terrain');
                this.views.noise = new Visualizer('canvas-noise');
                this.bulletSim = new BulletSim('canvas-bullet');
                this.enemySim = new EnemySim('canvas-enemy');

                document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(btn.dataset.target).classList.add('active');
                    this.state.activeTab = btn.dataset.target;
                }));

                this.initTerrainUI();
                this.initNoiseUI();
                this.initBulletUI();
                this.initEnemyUI();

                requestAnimationFrame(t => this.loop(t));
            },

            initTerrainUI() {
                const sel = document.getElementById('terrain-preset');
                const txt = document.getElementById('input-terrain');

                // Load from GameData.Library.Terrains
                Object.keys(GameData.Library.Terrains).forEach(k => sel.add(new Option(k, k)));

                const load = () => {
                    this.state.terrainConfig = JSON.parse(JSON.stringify(GameData.Library.Terrains[sel.value]));
                    txt.value = JSON.stringify(this.state.terrainConfig, null, 4);
                };
                sel.addEventListener('change', load);
                document.getElementById('btn-apply-terrain').addEventListener('click', () => {
                    try { this.state.terrainConfig = JSON.parse(txt.value); } catch (e) { }
                });
                if (sel.options.length > 0) load();
            },

            initNoiseUI() {
                const sel = document.getElementById('select-algo');
                const txt = document.getElementById('input-noise');
                const editor = document.getElementById('code-editor');
                const status = document.getElementById('compile-status');

                const refreshList = () => {
                    const current = sel.value;
                    sel.innerHTML = '';
                    // Load from GameData.Library.Noise
                    Object.keys(GameData.Library.Noise).forEach(k => sel.add(new Option(k, k)));
                    if (current && GameData.Library.Noise[current]) sel.value = current;
                };
                refreshList();

                const updateView = () => {
                    const name = sel.value;
                    this.state.noiseConfig = { scale: 8, speed: 1.0, colorize: false };
                    txt.value = JSON.stringify(this.state.noiseConfig, null, 4);
                    editor.value = this.noiseGen.getSourceBody(name);
                    editor.classList.remove('error');
                    status.innerText = "AST: Ready to parse.";
                    status.className = "status-msg status-ok";
                };

                const apply = () => {
                    try {
                        this.state.noiseConfig = JSON.parse(txt.value);
                        this.noiseGen.replace(sel.value, editor.value);
                        editor.classList.remove('error');
                        status.innerText = "AST: Valid Syntax. Compiled Successfully.";
                        status.className = "status-msg status-ok";
                    } catch (e) {
                        editor.classList.add('error');
                        status.innerText = e.message;
                        status.className = "status-msg status-err";
                    }
                };

                sel.addEventListener('change', updateView);
                document.getElementById('btn-apply-noise').addEventListener('click', apply);
                updateView();
            },

            initBulletUI() {
                const sel = document.getElementById('select-bullet');
                const spawnEditor = document.getElementById('input-bullet-config');
                const behaviorEditor = document.getElementById('input-bullet-behavior');
                const status = document.getElementById('bullet-compile-status');
                const pTxt = document.getElementById('input-player-config');

                Object.keys(GameData.Library.Bullets).forEach(k => sel.add(new Option(k, k)));

                const load = () => {
                    const def = GameData.Library.Bullets[sel.value];
                    if (!def) return;

                    spawnEditor.value = `// Spawn Script for ${sel.value}
    ctx.spawn({
        speed: ${def.speed || 6},
        angle: -90,
        color: '${def.color || '#ff0'}',
        size: ${def.radius || 4}
    });`;

                    behaviorEditor.value = def.behavior || "b.x += b.vx;\nb.y += b.vy;";

                    apply();
                };

                const apply = () => {
                    status.className = "status-msg";
                    status.innerText = "Compiling...";

                    try {
                        this.state.playerConfig = JSON.parse(pTxt.value);
                    } catch (e) { }

                    const spawnCheck = CodeParser.validate(spawnEditor.value, 'p, t, ctx');
                    if (!spawnCheck.valid) {
                        status.className = "status-msg status-err";
                        status.innerText = `Spawn Error: ${spawnCheck.message}`;
                        spawnEditor.classList.add('error');
                        return;
                    }
                    spawnEditor.classList.remove('error');

                    const behaviorCheck = CodeParser.validate(behaviorEditor.value, 'b, t, ctx');
                    if (!behaviorCheck.valid) {
                        status.className = "status-msg status-err";
                        status.innerText = `Behavior Error: ${behaviorCheck.message}`;
                        behaviorEditor.classList.add('error');
                        return;
                    }
                    behaviorEditor.classList.remove('error');

                    try {
                        this.bulletSim.spawnLogic = new Function('p', 't', 'ctx', spawnEditor.value);
                        this.bulletSim.behaviorLogic = new Function('b', 't', 'ctx', behaviorEditor.value);
                        status.className = "status-msg status-ok";
                        status.innerText = "AST: Valid Syntax. Compiled Successfully.";
                    } catch (e) {
                        status.className = "status-msg status-err";
                        status.innerText = `Runtime Compile Error: ${e.message}`;
                    }
                };

                document.getElementById('btn-load-bullet').addEventListener('click', load);
                document.getElementById('btn-apply-bullet').addEventListener('click', apply);
                sel.addEventListener('change', load);

                if (sel.options.length > 0) load();
            },

            initEnemyUI() {
                const sel = document.getElementById('select-enemy');
                const cTxt = document.getElementById('input-enemy-config');
                const aiTxt = document.getElementById('input-enemy-ai');
                const status = document.getElementById('enemy-compile-status');

                Object.keys(GameData.Library.Enemies).forEach(k => sel.add(new Option(k, k)));

                const load = () => {
                    const def = GameData.Library.Enemies[sel.value];
                    if (!def) return;
                    const config = { hp: def.hp, radius: def.radius, color: def.color, score: def.score };
                    cTxt.value = JSON.stringify(config, null, 4);
                    aiTxt.value = CodeParser.extractBody(def.ai.toString());
                    apply();
                };

                const apply = () => {
                    try {
                        this.state.enemyConfig = JSON.parse(cTxt.value);
                        const check = CodeParser.validate(aiTxt.value, 'me, ctx');
                        if (!check.valid) throw new Error(`Syntax Error: ${check.message}`);

                        status.innerText = "AST: Valid Syntax. AI Updated.";
                        status.className = "status-msg status-ok";
                        aiTxt.classList.remove('error');

                        this.enemySim.reset(this.state.enemyConfig, aiTxt.value);
                    } catch (e) {
                        status.innerText = e.message;
                        status.className = "status-msg status-err";
                        aiTxt.classList.add('error');
                    }
                };

                document.getElementById('btn-load-enemy').addEventListener('click', load);
                document.getElementById('btn-apply-enemy').addEventListener('click', apply);
                document.getElementById('btn-reset-enemy').addEventListener('click', () => {
                    this.enemySim.reset(this.state.enemyConfig, aiTxt.value);
                });

                if (sel.options.length > 0) load();
            },

            loop(t) {
                const time = t * 0.001;

                if (this.state.activeTab === 'editor') {
                    this.state.scrollY -= 2;
                    this.views.terrain.drawTerrain(this.terrainSys, this.state.terrainConfig, this.state.scrollY);
                } else if (this.state.activeTab === 'gallery') {
                    this.views.noise.drawNoise(this.noiseGen, document.getElementById('select-algo').value, this.state.noiseConfig, time);
                } else if (this.state.activeTab === 'bullet-sim') {
                    this.bulletSim.update(this.state.playerConfig);
                    this.bulletSim.draw(this.state.playerConfig);
                } else if (this.state.activeTab === 'enemy-sim') {
                    this.enemySim.update();
                    this.enemySim.draw();
                }

                requestAnimationFrame(t => this.loop(t));
            }
        };

        App.init();
    </script>
</body>

</html>